<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>mpickering.github.io</title>
    <link href="http://mpickering.github.io/atom.xml" rel="self" />
    <link href="http://mpickering.github.io" />
    <id>http://mpickering.github.io/atom.xml</id>
    <author>
        <name>Matthew Pickering</name>
        <email>matthewtpickering@gmail.com</email>
    </author>
    <updated>2020-03-16T00:00:00Z</updated>
    <entry>
    <title>An IDE implemented using reflex</title>
    <link href="http://mpickering.github.io/posts/2020-03-16-ghcide-reflex.html" />
    <id>http://mpickering.github.io/posts/2020-03-16-ghcide-reflex.html</id>
    <published>2020-03-16T00:00:00Z</published>
    <updated>2020-03-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> An IDE implemented using reflex </h2>
<p class="text-muted">
    Posted on March 16, 2020
    
</p>

<p>Around this point last year I set out to reimplement a lot of the backend of <code>haskell-ide-engine</code> in order to make it more easily usable with a wide variety of build tools. This effort was largely a success and my branch was merged just before Christmas thanks to the extensive help of Zubin Duggal, Fendor, Alan Zimmerman, Luke Lau and Javier Neira. The main result was an IDE based on the <code>hie-bios</code> library which abstracts the interface to the different build tools so the IDE itself doesn’t have to worry about how to set up the GHC session.</p>
<p>Since then, the situation is vastly different with the focus now turning to <code>ghcide</code> and <code>hls</code>. <code>ghcide</code> is generally faster and more robust than <code>haskell-ide-engine</code> because it reimplements certain parts of the GHC API which allow for finer grain recompilation checking. The future extension, <code>hls</code>, will extend <code>ghcide</code> with support for code formatters and other diagnostics. I have found implementing extensions to <code>ghcide</code> much easier and more robust. Both <code>ghcide</code> and <code>hls</code> are built on top of <code>hie-bios</code>.</p>
<p>At Munihac 2019, Neil Mitchell gave a <a href="https://www.youtube.com/watch?v=cijsaeWNf2E">presentation</a> where he described the motivation for <code>ghcide</code> and a general description of the architecture. In his talk, he describes how you can think of an IDE as a dependency graph, which was greeted by an audience heckle suggesting an FRP library could be used to implement the IDE. The current implementation is based on shake, which has similar properties to an FRP library but with some crucial differences.</p>
<p>The pull-based model of shake does not scale well to large code bases. All requests scale linearly with the number of dependencies which means that even requests such as hovering can take upwards of 1s on a module with a large number of transitive dependencies. A 1s hover response time was enough to get me interested and after attempting to <a href="https://github.com/digital-asset/ghcide/pull/384">improve the performance</a> I decided that without a fundamental rewrite, the situation could not be improved.</p>
<p>So spurred on by the heckle and the desire for subsecond reponse times it was time to put the money where my mouth was and attempt to reimplement the backend using <code>reflex</code> instead of <code>shake</code>. Reflex is push-based which means once the network is constructed changes propagate from input events rather than being pulled from samples. This seemed like a better model for an IDE.</p>
<p>What did I imagine the primary benefits to this project would be?</p>
<ul>
<li>I wanted to prove it was possible.</li>
<li>Using the push-based model means that requests such as hovering can return instantly rather than checking to see if any dependencies have updated.</li>
<li>Handlers for LSP requests can be written in the same language as the functions which computed the module graph.</li>
</ul>
<p>In short, I <a href="https://github.com/mpickering/ghcide/tree/reflex">now have an IDE</a> which works and is completely implemented using reflex which gives you a point to be able to evaluate the costs and benefits to both approaches.</p>
<p>In this post I will describe some of the basic abstractions which I implemented using <code>reflex</code> which gives writing the IDE a similar feel. The rest of this post is aimed at people who are already familiar with <code>reflex</code> and goes into a reasonable amount of detail about specific things to do with reflex and design decisions I had to make.</p>
<!--more-->
<h1 id="implementation">Implementation</h1>
<p>An early goal of the implementation was to try to reuse as much code as possible from <code>ghcide</code>. The end result was that I could reuse almost all the code for the rule definitions but had to rewrite a lot of the code which dealt with input events. Therefore there are two main parts to the implementation: the specification of rules and the interpretation of rules into a reflex network.</p>
<h2 id="step-1-what-is-a-rule">Step 1: What is a rule?</h2>
<p>The program is structured by rules, there is one rule type for each of the different stages of the compilation pipeline. The user provides definitions for these rules and then the rules are combined to form the reflex network.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">RuleType</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="dt">GetFileContents</span><span class="ot"> ::</span> <span class="dt">RuleType</span> (<span class="dt">FileVersion</span>, <span class="dt">Maybe</span> <span class="dt">T.Text</span>)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="dt">GetParsedModule</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">ParsedModule</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="dt">GetLocatedImports</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">LocatedImports</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="dt">GetSpanInfo</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">SpansInfo</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="dt">GetDependencyInformation</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">DependencyInformation</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="dt">GetDependencies</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">TransitiveDependencies</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  <span class="dt">GetTypecheckedModule</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">TcModuleResult</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="dt">ReportImportCycles</span><span class="ot"> ::</span> <span class="dt">RuleType</span> ()</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="dt">GenerateCore</span><span class="ot"> ::</span> <span class="dt">RuleType</span> (<span class="dt">SafeHaskellMode</span>, <span class="dt">CgGuts</span>, <span class="dt">ModDetails</span>)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="dt">GenerateByteCode</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">Linkable</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  <span class="dt">GhcSession</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">HscEnvEq</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  <span class="dt">GetHiFile</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">HiFileResult</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  <span class="dt">GetModIface</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">HiFileResult</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  <span class="dt">IsFileOfInterest</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">Bool</span></a></code></pre></div>
<p>A <code>RuleType</code> is a per-module rule, therefore for each module we can ask to get the parsed module for that module and a bunch of other information. As a first approximation, the result of each rule will be stored in a <code>Dynamic</code>.</p>
<p>The monad which is used for defining rules is called <code>ActionM</code>, inside the <code>ActionM</code> monad you can do two things.</p>
<ol type="1">
<li>Run IO actions using <code>liftIO</code>.</li>
<li>Request the value of existing rules, using <code>use</code> or <code>use_</code>.</li>
</ol>
<p><code>use</code> is a function which allows you to ask what the current value of a specific rule is.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">use ::</span> _ <span class="ot">=&gt;</span> <span class="dt">RuleType</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">         <span class="ot">-&gt;</span> <span class="dt">NormalizedFilePath</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">         <span class="ot">-&gt;</span> <span class="dt">ActionM</span> t m (<span class="dt">Maybe</span> a)</a></code></pre></div>
<p>Whenever <code>use</code> is invoked in a rule definition, a dependency is added on the value was was sampled. If the value changes in future, the rule will run again and the result recomputed.</p>
<p>Rule definition therefore end up looking a lot like the original shake rule definitions.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">generateByteCodeRule ::</span> <span class="dt">WRule</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">generateByteCodeRule <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    define <span class="dt">GenerateByteCode</span> <span class="fu">$</span> \file <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">      deps <span class="ot">&lt;-</span> use_ <span class="dt">GetDependencies</span> file</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">      (tm <span class="fu">:</span> tms) <span class="ot">&lt;-</span> uses_ <span class="dt">GetTypecheckedModule</span> (file<span class="fu">:</span> transitiveModuleDeps deps)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">      session <span class="ot">&lt;-</span> hscEnv <span class="fu">&lt;$&gt;</span> use_ <span class="dt">GhcSession</span> file</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">      (_, guts, _) <span class="ot">&lt;-</span> use_ <span class="dt">GenerateCore</span> file</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">      liftIO <span class="fu">$</span> generateByteCode session [(tmrModSummary x, tmrModInfo x) <span class="fu">|</span> x <span class="ot">&lt;-</span> tms] tm guts</a></code></pre></div>
<p>The bytecode rule will rerun if the dependencies of the file change, the result of typechecking changes, the current session changes or the generated core changes.</p>
<h3 id="defining-rules">Defining rules</h3>
<p>Once the body of a rule definition is defined, there are several ways to specify the definition. The simplest is <code>define</code>, which does not implement early cut-off or external triggering. There are other variants which enable both of these features.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">define ::</span> <span class="dt">RuleType</span> a <span class="ot">-&gt;</span> (forall t <span class="fu">.</span> <span class="dt">C</span> t <span class="ot">=&gt;</span> <span class="dt">NormalizedFilePath</span> <span class="ot">-&gt;</span> <span class="dt">ActionM</span> t (<span class="dt">HostFrame</span> t) a) <span class="ot">-&gt;</span> <span class="dt">WRule</span></a></code></pre></div>
<p>Once a rule is defined, like in shake, you put them all in a list and pass them into the function which creates the reflex network.</p>
<h2 id="representing-a-node-in-the-network">Representing a node in the network</h2>
<p>Each rule is implemented by an <code>MDynamic</code>, which is a refined <code>Dynamic</code> which implements early cut-off and lazy initialisation. Early cut-off means that the dynamic will only fire if the value is updated to a new value. Lazy initialisation means that the dynamic will only be populated after it has been demanded once.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">MDynamic</span> t a <span class="fu">=</span> <span class="dt">MDynamic</span> {<span class="ot"> getMD ::</span> <span class="dt">Dynamic</span> t (<span class="dt">Early</span> (<span class="dt">Thunk</span> a)) }</a></code></pre></div>
<p>The combination of both of these features means that less events are propagated in the network, something we really want to avoid in order to avoid running expensive IO computations.</p>
<h3 id="early-cut-off">Early Cut-off</h3>
<p>Early cut-off is implemented by using the <code>Early</code> wrapper.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Early</span> a <span class="fu">=</span> <span class="dt">Early</span> (<span class="dt">Maybe</span> <span class="dt">BS.ByteString</span>) <span class="dt">Int</span> a</a></code></pre></div>
<p>The data type stores a hash of the current value and an integer which indicates the number of times the value has been updated (this is used for debugging).</p>
<p>The value in the <code>Early</code> is only updated if either there is no hash or the hash of the new value is different to the hash of the old value.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">early ::</span> (<span class="dt">Reflex</span> t, <span class="dt">MonadHold</span> t m, <span class="dt">MonadFix</span> m) <span class="ot">=&gt;</span> <span class="dt">Dynamic</span> t (<span class="dt">Maybe</span> <span class="dt">BS.ByteString</span>, a) <span class="ot">-&gt;</span> m (<span class="dt">Dynamic</span> t (<span class="dt">Early</span> a))</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">early d <span class="fu">=</span> scanDynMaybe (\(h, v) <span class="ot">-&gt;</span> <span class="dt">Early</span> h <span class="dv">0</span> v) upd d</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="co">-- Nothing means there&#39;s no hash, so always update</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    upd (<span class="dt">Nothing</span>, a) (<span class="dt">Early</span> _ n _) <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Early</span> <span class="dt">Nothing</span> (n <span class="fu">+</span> <span class="dv">1</span>) a)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    <span class="co">-- If there&#39;s already a hash, and we get a new hash then update</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    upd (<span class="dt">Just</span> h, new_a) (<span class="dt">Early</span> (<span class="dt">Just</span> h&#39;) n _) <span class="fu">=</span> <span class="kw">if</span> h <span class="fu">==</span> h&#39;</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">                                                  <span class="kw">then</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">                                                  <span class="kw">else</span> (<span class="dt">Just</span> (<span class="dt">Early</span> (<span class="dt">Just</span> h&#39;) (n <span class="fu">+</span> <span class="dv">1</span>) new_a))</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    <span class="co">-- No stored, hash, just update</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    upd (h, new_a) (<span class="dt">Early</span> <span class="dt">Nothing</span> n _)   <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Early</span> h (n <span class="fu">+</span> <span class="dv">1</span>) new_a)</a></code></pre></div>
<p>Most rules do not use the early cut-off functionality and hence the hash is always <code>Nothing</code>.</p>
<h3 id="lazy-initialisation">Lazy initialisation</h3>
<p>Without proper care, when the state for a module is initialised all the information about that module will be computed despite the fact most of it will never be used. For example, you will not need the core for most modules but in early versions of the project the core was always produced because on the first run of the rule, it was observed to depend on the typechecked module and hence was updated when the typechecked module was updated.</p>
<p>In order to solve this we implement the <code>Thunk</code> data type which has three distinct states:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Thunk</span> a <span class="fu">=</span> <span class="dt">Value</span> a <span class="fu">|</span> <span class="dt">Awaiting</span> <span class="fu">|</span> <span class="dt">Seed</span> (<span class="dt">IO</span> ()) <span class="kw">deriving</span> <span class="dt">Functor</span></a></code></pre></div>
<p>A thunk either contains a value, is awaiting a value to be provided to it or is inactive. All thunks start out as inactive and are activated by calling the <code>IO</code> action contained within the <code>Seed</code> constructor.</p>
<p>When a thunk is sampled, it is activated if it has never been activated before.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">sampleThunk ::</span> (<span class="dt">Reflex</span> t, <span class="dt">MonadIO</span> m, <span class="dt">MonadSample</span> t m) <span class="ot">=&gt;</span> <span class="dt">Dynamic</span> t (<span class="dt">Thunk</span> a) <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">sampleThunk d <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  t <span class="ot">&lt;-</span> sample (current d)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="kw">case</span> t <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    <span class="dt">Seed</span> start <span class="ot">-&gt;</span> liftIO start <span class="fu">&gt;&gt;</span> return <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    <span class="dt">Awaiting</span>   <span class="ot">-&gt;</span> return <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    <span class="dt">Value</span> a    <span class="ot">-&gt;</span> return (<span class="dt">Just</span> a)</a></code></pre></div>
<p>It is also important to implement a version of the <code>improvingMaybe</code> combinator to avoid propagating a lot of updates in the case when the dynamic is repeatedly updated to an <code>Awaiting</code> value. So a thunk can step from a <code>Seed</code> to an <code>Awaiting</code> and from an <code>Awaiting</code> to a <code>Value</code> but never back again.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">-- Like improvingMaybe, but for the Thunk type</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">improvingResetableThunk  ::</span>  (<span class="dt">MonadFix</span> m, <span class="dt">MonadHold</span> t m, <span class="dt">Reflex</span> t, <span class="dt">MonadIO</span> m, <span class="dt">MonadSample</span> t m) <span class="ot">=&gt;</span> <span class="dt">Dynamic</span> t (<span class="dt">Thunk</span> a) <span class="ot">-&gt;</span> m (<span class="dt">Dynamic</span> t (<span class="dt">Thunk</span> a))</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">improvingResetableThunk <span class="fu">=</span> scanDynMaybe id upd</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="co">-- ok, if you insist, write the new value</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    upd (<span class="dt">Value</span> a) _ <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Value</span> a)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    <span class="co">-- Wait, once the trigger is pressed</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    upd <span class="dt">Awaiting</span>  (<span class="dt">Seed</span> {}) <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Awaiting</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    upd _ _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>It will be good in future to allow resetting thunks in order to implement garbage collection. It is probably that we want to allow reseting from a <code>Just</code> back to a <code>Nothing</code> in order to avoid stale information in the network.</p>
<h2 id="step-2-what-is-a-global-variable">Step 2: What is a global variable?</h2>
<p>There is also a global rule type for parts of the IDE state which are not dependent on a specific module.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">GlobalType</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="dt">GetHscEnv</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">SessionMap</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="dt">GhcSessionIO</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">GhcSessionFun</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="dt">GetEnv</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">HscEnv</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  <span class="dt">GetIdeOptions</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">IdeOptions</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  <span class="dt">OfInterestVar</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> (<span class="dt">HashSet</span> <span class="dt">NormalizedFilePath</span>)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="dt">FileExistsMapVar</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">FileExistsMap</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  <span class="dt">GetVFSHandle</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">VFSHandle</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  <span class="dt">GetInitFuncs</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">InitParams</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  <span class="dt">IdeConfigurationVar</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">IdeConfiguration</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  <span class="dt">GetPositionMap</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">PositionMap</span></a></code></pre></div>
<p>Module rules can depend on global rules in the same manner as per-module rules. The interface for defining a global rule is slightly different to a local rule because the global variables are usually directly populated from events. For example, the <code>OfInterestVar</code> is modified by the user opening and closing files in their editer and hence it is defined as the combination of these two events.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">addIdeGlobal ::</span> <span class="dt">GlobalType</span> a <span class="ot">-&gt;</span> (forall t <span class="fu">.</span> <span class="dt">C</span> t <span class="ot">=&gt;</span> (<span class="dt">ReaderT</span> (<span class="dt">REnv</span> t) m (<span class="dt">Dynamic</span> t a))) <span class="ot">-&gt;</span> <span class="dt">WRule</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">ofInterestVar ::</span> <span class="dt">WRule</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">ofInterestVar <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  addIdeGlobal <span class="dt">OfInterestVar</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    e1 <span class="ot">&lt;-</span> withNotification <span class="fu">&lt;$&gt;</span> getHandlerEvent didOpenTextDocumentNotificationHandler</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    e2 <span class="ot">&lt;-</span> withNotification <span class="fu">&lt;$&gt;</span> getHandlerEvent didCloseTextDocumentNotificationHandler</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">    upd <span class="ot">&lt;-</span> logAction <span class="dt">Info</span> (fmapMaybe check e1)</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    upd2 <span class="ot">&lt;-</span> logAction <span class="dt">Info</span> (fmapMaybe check2 e2)</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    foldDyn (<span class="fu">$</span>) S.empty (mergeWith (<span class="fu">.</span>) [upd, upd2])</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">      check (<span class="dt">DidOpenTextDocumentParams</span> <span class="dt">TextDocumentItem</span>{_uri, _version}) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">        whenUriFile _uri <span class="dt">Nothing</span> <span class="fu">$</span> \file <span class="ot">-&gt;</span> <span class="dt">Just</span> (add file, <span class="st">&quot;Opened text document: &quot;</span> <span class="fu">&lt;&gt;</span> getUri _uri)</a>
<a class="sourceLine" id="cb12-14" data-line-number="14"></a>
<a class="sourceLine" id="cb12-15" data-line-number="15"></a>
<a class="sourceLine" id="cb12-16" data-line-number="16">      check2 (<span class="dt">DidCloseTextDocumentParams</span> <span class="dt">TextDocumentIdentifier</span>{_uri}) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">        whenUriFile _uri <span class="dt">Nothing</span> <span class="fu">$</span> \file <span class="ot">-&gt;</span> <span class="dt">Just</span> (remove file, <span class="st">&quot;Closed text document:&quot;</span> <span class="fu">&lt;&gt;</span> getUri _uri)</a>
<a class="sourceLine" id="cb12-18" data-line-number="18">      add file <span class="fu">=</span> S.insert file</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">      remove file <span class="fu">=</span> S.delete file</a></code></pre></div>
<p>A global is defined in an environment with the other global dynamics and must return a dynamic which is created by combining them together.</p>
<h2 id="definition-3-what-is-an-unit-action">Definition 3: What is an unit action?</h2>
<p>The third type of definition is the unit action. Unit actions are useful for parts of your program which don’t contribute any state in the form of definitions. For example, hooking up diagnostics to the output, responding to hover requests, logging and progress notifications.</p>
<p>Unit actions are defined using the <code>unitAction</code> function.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">unitAction ::</span> (forall t <span class="fu">.</span> <span class="dt">C</span> t <span class="ot">=&gt;</span> <span class="dt">BasicM</span> t (<span class="dt">BasicGuestWrapper</span> t) ())</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">           <span class="ot">-&gt;</span> <span class="dt">WRule</span></a></code></pre></div>
<p>A unit action is an action which only operates in a reader environment where it can depend on the value of other dynamics but must eventually return unit. For example, in a unit action you can create a local dynamic which combines different dynamics from the global state together before outputting the result to the user. This is how diagnostics are implemented before being fed into the function which sends output back to the language client.</p>
<h1 id="evaluating-the-rule-specification">Evaluating the rule specification</h1>
<p>Once we have a list of module rules, global rules and actions, they are combined together in order to form the reflex network. Each global rule is evaluated and turned into a dynamic, module rules are used to define the per-module state when we discover a new file and finally actions are all evaluated to connect additional parts of the network together.</p>
<h2 id="evaluating-a-rule">Evaluating a rule</h2>
<p>The heart of the implementation is in how the rules report their dependencies in the form of an <code>Event</code>, which is then used in order to trigger the action in future. This is elegantly expressed recursively in five lines. The result of the call to performAction is <code>Event t (IdeResult a, [Event t EType])</code>, which is the separated using <code>splitE</code> before the dependency events are combined with <code>mkDepTrigger</code> and then used in order to define <code>rebuild_trigger</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">rule <span class="fu">=</span> mdo</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="co">-- The event which will trigger a rebuild</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    <span class="kw">let</span> rebuild_trigger <span class="fu">=</span> (fmap (\e <span class="ot">-&gt;</span> leftmost [user_trig&#39;, start_trigger, e]) deps&#39;)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    act_trig <span class="ot">&lt;-</span> switchHoldPromptly start_trigger rebuild_trigger</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    <span class="co">-- When the trigger fires, run the rule</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    pm <span class="ot">&lt;-</span> performAction renv (act f) act_trig</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="co">-- Separate the dependencies from the actual result</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    <span class="kw">let</span> (act_res, deps) <span class="fu">=</span> splitE pm</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    <span class="kw">let</span> deps&#39; <span class="fu">=</span> pushAlways mkDepTrigger deps</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">    <span class="fu">...</span></a></code></pre></div>
<p>The use of <code>switchHoldPromptly</code> is absolutely key to the implementation. It is imperative that if in the same frame a dependency fires then we need to immediately rerun the rule. The network is left in an inconsistent state is the simpler <code>switchHold</code> is used.</p>
<p>Further processing to the returned result is performed to convert it into an <code>MDynamic</code> which is then stored in the state.</p>
<h2 id="a-note-about-the-module-state">A note about the module state</h2>
<p>The per-module state is a pair of a map from the rule type to an <code>MDynamic</code> and an event which reports diagnostics for that module.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ModuleState</span> t <span class="fu">=</span> <span class="dt">ModuleState</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">      {<span class="ot"> rules ::</span> <span class="dt">DMap</span> <span class="dt">RuleType</span> (<span class="dt">MDynamic</span> t)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">      ,<span class="ot"> diags ::</span> <span class="dt">Event</span> t (<span class="dt">NL.NonEmpty</span> <span class="dt">DiagsInfo</span>) }</a></code></pre></div>
<p>The state for all modules is stored in a map from the filepath to one of these module state records.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ModuleMap</span> t <span class="fu">=</span> <span class="dt">Incremental</span> t (<span class="dt">PatchMap</span> <span class="dt">NormalizedFilePath</span> (<span class="dt">ModuleState</span> t))</a></code></pre></div>
<p>Using a <code>Dynamic</code> or <code>Incremental</code> here is important because it means values of the map can be altered as the network is evaluated. For our use-case as we do not know the dependencies of a module until we have parsed the module header.</p>
<p>So when a module rule is attempted to be sampled, there are in fact two possible modes of failure which we can recover from.</p>
<ol type="1">
<li>Either the module has never been seen before, so we should initialise the module state for this module.</li>
<li>The value for the rule has not been computed yet, so we should recompute the rule when it is available.</li>
</ol>
<p>In order to report that a sample failed for the first reason, the module map is paired with an action which can be called to trigger the event which adds a new module to the map.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ModuleMapWithUpdater</span> t <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="dt">MMU</span> {</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">    getMap ::</span> <span class="dt">ModuleMap</span> t</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    ,<span class="ot"> updateMap ::</span> [(<span class="dt">D.Some</span> <span class="dt">RuleType</span>, <span class="dt">NormalizedFilePath</span>)] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    }</a></code></pre></div>
<p>The second situation is dealt with by the <code>Thunk</code> mechanism described in the previous situation.</p>
<p>Note: There is a place where using <code>batchOccurences</code> is very useful because during the initialisation of the network, this trigger can be called hundreds of times and it is much more efficient to collect together as many updates as possible.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">map_update&#39; <span class="ot">&lt;-</span> fmap concat <span class="fu">&lt;$&gt;</span> batchOccurrences <span class="fl">0.1</span> map_update</a></code></pre></div>
<h1 id="interaction-with-the-language-client">Interaction with the language client</h1>
<p>In the global environment as well as the global variables as defined by rules, there is a collection of events which correspond to external events.</p>
<ul>
<li>One event which fires after the language server is initialised, this populates a few global dynamics.</li>
<li>A record of events which fire whenever the server recieves a notification of request from the client. For example, when the user opens or modifies a file, the event fires.</li>
</ul>
<p>As part of an action definition it is possible to also provide an additional event trigger, constructed from these events, which causes the rule to fire. For example, when a file is saved, the rule which parses a file fires again which causes the changes to propagate through the network.</p>
<p>Global variables are typically constructed by holding these notification events. It is a much nicer model in my opinion than the style previously found in <code>ghcide</code> where there where some variables were mutated in the handlers and the whole shake graph invalidated.</p>
<p>Note: The way this handler record is constructed by leveraging the <code>barbies</code> library is <a href="https://github.com/mpickering/ghcide/blob/reflex/src/Development/IDE/Core/Reflex/Service.hs#L257">interesting</a> in its own right.</p>
<h1 id="evaluation">Evaluation</h1>
<p>I found it important to be able to inspect certain properties of my network during the implementation process. In particular, there were situations where actions were running more than I expected so I wanted to analyse what was causing each rule to fire. There is unfortunately not an existing framework built into reflex for this but it was possible to instrument the application to get some good information.</p>
<p>I started by defining a data type which enumerates the different possible ways a rule can fire.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co">-- EType is mainly used for debugging why an event is firing too often.</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="kw">data</span> <span class="dt">EType</span> <span class="fu">=</span> <span class="dt">DepTrigger</span> (<span class="dt">D.Some</span> <span class="dt">RuleType</span>, <span class="dt">NormalizedFilePath</span>)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">              <span class="fu">|</span> <span class="dt">MissingTrigger</span> <span class="dt">NormalizedFilePath</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">              <span class="fu">|</span> <span class="dt">StartTrigger</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">              <span class="fu">|</span> <span class="dt">UserTrigger</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>Then each event which could contribute to an action firing is tagged with one of these constructors. When the event fires I used <code>traceEvent</code> in order to output both the action which was firing and the reason for it. Then by capturing this log and using standard unix commands it was possible to analyse situations where things were happening more often than not.</p>
<p>This was the method where I realised it was necessary to use <code>headE</code> in order to make sure the <code>StartTrigger</code> event would only fire one time.</p>
<h1 id="whats-next">What’s next?</h1>
<p>So we’ve achieved our goal of proving the implementation is possible but there are still a few places the implementation could be improved. I have also not extensively tested the branch, it is likely there are some bugs to do with stale information.</p>
<h3 id="progress-reporting">Progress Reporting</h3>
<p>It isn’t clear to me how to implement progress reporting for the IDE at the moment. All changes to the system are driven by push events, which means that when an event fires the amount of work which will be done can not be determined. This is compounded by the fact reflex is a monadic FRP library so how much is left to do depends on the result of running the rules.</p>
<h3 id="better-profiling">Better Profiling</h3>
<p>It would be good to have a profiling mode like shake’s profiling mode so the effect of each input event could be analysed in detail. At the moment there is nothing in the reflex ecosystem which can help with this analysis.</p>
<h3 id="asynchronous-actions">Asynchronous Actions</h3>
<p>It would be very beneficial if the rules could run in separate threads because currently the whole application blocks whilst IO actions are being computed. The usage of <code>MonadSample</code> is not currently compatible with using <code>performEvent</code> asynchronously.</p>
<h3 id="dynamic-rule-registration">Dynamic Rule Registration</h3>
<p>For my own sanity, I decided to use a fixed set of rules, as defined by <code>RuleType</code> in my implementation rather than a dynamic map of rules, as implemented in shake. I have considered a few types going for the dynamic map approach, as it would also be useful for plugins but it has been a low priority for the proof of concept implementation.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I had a great time implementing this fork, my second extensive rewrite of a Haskell IDE. I’m looking forward to rewriting an IDE again next year.</p>
<h2 id="related-links">Related Links</h2>
<ul>
<li><a href="https://github.com/mpickering/ghcide/tree/reflex">Project Branch</a></li>
<li>Reddit discussion</li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Introducing hs-speedscope - a way to visualise time profiles</title>
    <link href="http://mpickering.github.io/posts/2019-11-07-hs-speedscope.html" />
    <id>http://mpickering.github.io/posts/2019-11-07-hs-speedscope.html</id>
    <published>2019-11-07T00:00:00Z</published>
    <updated>2019-11-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Introducing hs-speedscope - a way to visualise time profiles </h2>
<p class="text-muted">
    Posted on November  7, 2019
    
</p>

<p>In GHC-8.10 it will become possible to use <a href="https://www.speedscope.app/">speedscope</a> to visualise the performance of a Haskell program. speedscope is an interactive flamegraph visualiser, we can use it to visualise the output of the <code>-p</code> profiling option. Here’s how to use it:</p>
<ol type="1">
<li>Run your program with <code>prog +RTS -p -l-au</code>. This will create an eventlog with cost centre stack sample events.</li>
<li>Convert the eventlog into the speedscope JSON format using <a href="https://github.com/mpickering/hs-speedscope"><code>hs-speedscope</code></a>. The <code>hs-speedscope</code> executable takes an eventlog file as the input and produces the speedscope JSON file.</li>
<li>Load the resulting <code>prog.eventlog.json</code> file into <a href="http://www.speedscope.app">speedscope.app</a>.</li>
</ol>
<!--more-->
<h2 id="using-speedscope">Using Speedscope</h2>
<p>Speedscope then has three modes for viewing the profile. The default mode shows you the executation trace of your program. The call stack extends downwards, the wider the box, the more time was spent in that part of the program. You can select part of the profile by selecting part of the minimap, zoom using <code>+/-</code> or pan using the arrow keys. The follow examples are from profiling GHC building Cabal:</p>
<p><a href="/images/speedscope1.png"><img src="/images/speedscope1.png" style="width:100.0%" /></a></p>
<p>The first summarised view is accessed by the “left-heavy” tab. This is like the summarised output of the <code>-p</code> flag. The cost centre stacks which account for the most time will be grouped together at the left of the view. This way you can easily see which executation paths take the longest over the course of the whole executation of the program.</p>
<p><a href="/images/speedscope2.png"><img src="/images/speedscope2.png" style="width:100.0%" /></a></p>
<p>Finally, the “sandwich” view tries to work out which specific cost centre is responsible for the most executation time. You can use this to try to understand the functions which take the most time to execute. How useful this view is depends on the resolution of your cost centres in your program. Speedscope attempts to work out the most expensive cost centre by subtracting the total time spent beneath that cost centre from the time spent in the cost centre. For example, if <code>f</code> calls <code>g</code> and <code>h</code>, the cost of in <code>f</code> is calculated by the total time for <code>f</code> minus the time spend in <code>g</code> and <code>h</code>. If the cost of <code>f</code> is high, then there is some computation happening in <code>f</code> which is not captured by any further cost centres.</p>
<p><a href="/images/speedscope3.png"><img src="../images/speedscope3.png" style="width:100.0%" /></a></p>
<h2 id="how-is-this-different-to-the-other-profile-visualisers">How is this different to the other profile visualisers?</h2>
<p>The most important difference is that I didn’t implement the visualiser, it is a generic visualiser which can support many different languages. I don’t have to maintain the visualiser or work out how to make it scale to very big profiles. You can easily load 60mb profiles using speedscope without any rendering problems. All the library does is directly convert the eventlog into the generic speedscope JSON format.</p>
<h2 id="how-is-this-different-to-the-support-already-in-speedscope">How is this different to the support already in speedscope?</h2>
<p>If you consult the documentation for speedscope you will see that it claims to support Haskell programs already. Rudimentary support has already been implemented by using the JSON output produced by the <code>-pj</code> flag but the default view which shows an executation trace of your program hasn’t worked correctly because the output of <code>-pj</code> is too generalised. If you program ends up calling the same code path many different times during the executation of the program, they are all identified in the final profile.</p>
<p>The second important difference is that each capability will be displayed on a separate profile. This makes profiling more useful for parallel programs.</p>
<h2 id="how-does-it-work">How does it work?</h2>
<p>I <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/1927">added support</a> to dump the raw output from <code>-p</code> to the eventlog. Now it’s possible to process the raw information in order to produce the format that speedscope requires.</p>
<h2 id="additional-links">Additional Links</h2>
<ul>
<li><a href="https://www.reddit.com/r/haskell/comments/dt9acz/introducing_hsspeedscope/">Reddit</a></li>
<li><a href="https://github.com/mpickering/hs-speedscope"><code>hs-speedscope</code></a></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Announcing Bristol Haskell Hackathon 2020</title>
    <link href="http://mpickering.github.io/posts/2019-10-21-bristol-haskell-2020.html" />
    <id>http://mpickering.github.io/posts/2019-10-21-bristol-haskell-2020.html</id>
    <published>2019-10-21T00:00:00Z</published>
    <updated>2019-10-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Announcing Bristol Haskell Hackathon 2020 </h2>
<p class="text-muted">
    Posted on October 21, 2019
    
</p>

<p>I have decided to organise an informal hackathon in Bristol at the start of next year.</p>
<div class="table">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">When</td>
<td style="text-align: left;">25th-26th January 2020</td>
</tr>
<tr class="even">
<td style="text-align: left;">Where</td>
<td style="text-align: left;"><a href="https://goo.gl/maps/x3q61a3zbyTfc7ZH6">Merchant Venturers Building - University of Bristol</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Time</td>
<td style="text-align: left;">09:00 - 17:00</td>
</tr>
</tbody>
</table>
</div>
<p>Anyone interested in Haskell is welcome to attend. Whether you are a beginner or an expert it would be great to meet you in Bristol.</p>
<p>It is a no-frills hackathon, we’ll provide a room for hacking and wifi but expect little else! There will be no t-shirts, food, talks or other perks. The focus will be 100% on hacking and meeting other Haskell programmers.</p>
<p>For further information about the event and how to register please refer to the dedicated page.</p>
<div class="text-center">
<p><a href="../bristol2020.html"><button type="button" class="btn btn-secondary">More information about Bristol 2020</button></a></p>
</div>
]]></summary>
</entry>
<entry>
    <title>Two new Haskell Symposium papers</title>
    <link href="http://mpickering.github.io/posts/2019-07-09-haskell-papers.html" />
    <id>http://mpickering.github.io/posts/2019-07-09-haskell-papers.html</id>
    <published>2019-07-09T00:00:00Z</published>
    <updated>2019-07-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Two new Haskell Symposium papers </h2>
<p class="text-muted">
    Posted on July  9, 2019
    
</p>

<p>This year I was lucky to have both my papers accepted for the Haskell Symposium. The first one is about the problematic interaction of Typed Template Haskell and implicit arguments and the second, a guide to writing source plugins. Read on the abstracts and download links.</p>
<!--more-->
<h3 id="multi-stage-programming-in-context">Multi Stage Programming in Context</h3>
<p>Matthew Pickering, Nicolas Wu, Csongor Kiss (<a href="../papers/multi-stage-programs-in-context.pdf">PDF</a>)</p>
<div class="blockquote">
<blockquote>
<p>Cross-stage persistence is an essential aspect of multi-stage programming that allows a value defined in one stage to be available in another. However, difficulty arises when implicit information held in types, type classes and implicit parameters needs to be persisted. Without a careful treatment of such implicit information—which are pervasive in Haskell—subtle yet avoidable bugs lurk beneath the surface.</p>
</blockquote>
<blockquote>
<p>This paper demonstrates that in multi-stage programming care must be taken when representing quoted terms so that important implicit information is not discarded. The approach is formalised with a type-system, and an implementation in GHC is presented that fixes problems of the previous incarnation.</p>
</blockquote>
</div>
<h3 id="working-with-source-plugins">Working with Source Plugins</h3>
<p>Matthew Pickering, Nicolas Wu, Boldizsár Németh (<a href="../papers/working-with-source-plugins.pdf">PDF</a>)</p>
<div class="blockquote">
<blockquote>
<p>A modern compiler calculates and constructs a large amount of information about the programs it compiles. Tooling authors want to take advantage of this information in order to extend the compiler in interesting ways. Source plugins are a mechanism implemented in the Glasgow Haskell Compiler (GHC) which allow inspection and modification of programs as they pass through the compilation pipeline.</p>
</blockquote>
<blockquote>
<p>This paper is about how to write source plugins. Due to their nature–they are ways to extend the compiler–at least basic knowledge about how the compiler works is critical to designing and implementing a robust and therefore successful plugin. The goal of the paper is to equip would-be plugin authors with inspiration about what kinds of plugins they should write and most importantly with the basic techniques which should be used in order to write them.</p>
</blockquote>
</div>
]]></summary>
</entry>
<entry>
    <title>Complete overkill or exactly right? Deploying a static site using nix</title>
    <link href="http://mpickering.github.io/posts/2019-06-24-overkill-or-not.html" />
    <id>http://mpickering.github.io/posts/2019-06-24-overkill-or-not.html</id>
    <published>2019-06-24T00:00:00Z</published>
    <updated>2019-06-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Complete overkill or exactly right? Deploying a static site using nix </h2>
<p class="text-muted">
    Posted on June 24, 2019
    
</p>

<p><a href="https://mpickering.github.io/eventlog2html/"><code>eventlog2html</code></a> is my new library for visualising Haskell heap profiles as an interactive webpage.</p>
<p>For the documentation, I thought it was important to provide some interactive examples which is why I decided to host my own static webpage rather than rely on a GitHub README. This led to two constraints:</p>
<ol type="1">
<li>The documentation is a static web page containing up-to-date examples of the tool’s output.</li>
<li>The page should be automatically deployed using CI.</li>
</ol>
<p>This post is a question about whether the combination of <a href="https://nixos.org/nix/">nix</a>, <a href="https://cachix.org/">Cachix</a>, <a href="https://travis-ci.org/">Travis CI</a>, <a href="https://input-output-hk.github.io/haskell.nix/">haskell.nix</a> and <a href="https://jaspervdj.be/hakyll/">Hakyll</a> was the perfect solution to these constraints or an exercise in overkill.</p>
<!--more-->
<h1 id="generating-the-static-site">Generating the static site</h1>
<p>The static site is generated using Hakyll. The content is written using markdown and rendered using pandoc. Inline charts are specified using special code blocks.</p>
<pre><code>```{.eventlog traces=False }
examples/ghc.eventlog --bands 10
```</code></pre>
<p>A <a href="https://pandoc.org/filters.html">pandoc filter</a> identifiers a code block which has the <code>eventlog</code> class and replaces it with the suitable visualisation. Options can be specified as attributes or using normal command line arguments.</p>
<p>Using a site generator implemented in Haskell meant that I could import <code>eventlog2html</code> as a library and use it directly without having to modify the external interface. This ended up being about <a href="https://github.com/mpickering/eventlog2html/blob/master/hakyll-eventlog/site.hs#L87">40 lines</a> for the filter which inserts eventlogs. There is also a <a href="https://github.com/mpickering/eventlog2html/blob/master/hakyll-eventlog/site.hs#L142">simpler filter</a> which inserts the result of calling <code>--help</code>.</p>
<p>Using Hakyll has already proved to be a good idea when I wanted to add the <a href="https://mpickering.github.io/eventlog2html/examples.html">examples gallery</a>. It was trivial to generate this page from a folder of eventlogs so that all I have to do to add a new eventlog is commit it to the repo.</p>
<p>So far, I haven’t broken the complexity budget. In order to satisfy the first constraint and keep the generated documentation up to date I created a package for the site. In the <code>cabal.project</code> file I then added the site’s folder as a subdirectory. Now, <code>hakyll-eventlog</code> will use the local version of <code>eventlog2html</code> as a dependency when it builds the site.</p>
<pre><code>packages: .
          hakyll-eventlog</code></pre>
<p>The site can be built and run using <code>cabal new-build hakyll-eventlog</code>. Now we move onto how to perform deployment of the generated site.</p>
<h1 id="deploying-using-travis">Deploying using Travis</h1>
<p>CircleCI and Travis are both popular CI providers and they can both to deploy to GitHub Pages. However, the Travis integration was far simpler to set up. There is built-in support for GitHub pages as a deployment target so a single stanza is necessary to perform the deployment.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">deploy:</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="fu">provider:</span><span class="at"> pages</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="fu">skip_cleanup:</span><span class="at"> true</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="fu">github_token:</span><span class="at"> $GITHUB_TOKEN</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="fu">keep_history:</span><span class="at"> true</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  <span class="fu">target_branch:</span><span class="at"> gh-pages</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="fu">local_dir:</span><span class="at"> site</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  <span class="fu">on:</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    <span class="fu">tags:</span><span class="at"> true</span></a></code></pre></div>
<p>The stanza says, deploy to GitHub pages by pushing the contents of the <code>site</code> directory to the <code>gh-pages</code> branch of the current repository. GitHub then serves the contents of the <code>gh-pages</code> branch on <code>https://mpickering.github.io/eventlog2html</code>.</p>
<p>Now all we need to do is generate the <code>site</code> directory. I found it quite daunting to modify the Travis script generated by <a href="http://hackage.haskell.org/package/haskell-ci"><code>haskell-ci</code></a> so at this point I decided to convert all the CI infrastructure to use nix instead.</p>
<h1 id="building-using-nix">Building using nix</h1>
<p>An obvious question at this stage is why is nix necessary at all? Wouldn’t a CI configuration which uses cabal have worked equally as well? On reflection, I could think of four reasons why I considered this to be a good idea.</p>
<ol type="1">
<li>Much more concise than the <code>haskell-ci</code> generated travis file.</li>
<li>Easier to run the same script locally</li>
<li>Easier for other nix users to use the project</li>
<li>Easy caching with Cachix</li>
</ol>
<h2 id="haskell.nix"><code>haskell.nix</code></h2>
<p>A key part in the decision was the new <a href="https://github.com/input-output-hk/haskell.nix"><code>haskell.nix</code></a> tooling to build Haskell packages. If you use the normal Haskell infrastructure which is built into nixpkgs then any collaborator has to know about nix in order to fix CI when it breaks. On the other hand, <code>haskell.nix</code> creates its derivations from the result of <code>cabal new-configure</code> so it matches up with using a <code>new-build</code> workflow locally.</p>
<p>Purity is retained by explicitly passing the <code>--index-state</code> flag to <code>new-configure</code> so anyone can update the CI configuration by changing the index state parameter in the <code>default.nix</code> file.</p>
<p>How does this look in practice? The <code>default.nix</code> is a very concise script which calls <code>haskell.nix</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="ex">pin</span> = import ((import ./nix/sources.nix)<span class="ex">.nixpkgs</span>) <span class="dt">{}</span> ;</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="co"># Import the Haskell.nix library,</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="ex">haskell</span> = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) <span class="kw">{</span> <span class="ex">pkgs</span> = pin<span class="kw">;</span> <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  <span class="co"># Generate the pkgs.nix file using callCabalProjectToNix IFD</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  <span class="ex">pkgPlan</span> = haskell.callCabalProjectToNix</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">              <span class="kw">{</span> <span class="ex">index-state</span> = <span class="st">&quot;2019-05-10T00:00:00Z&quot;</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">              ; <span class="ex">src</span> = pin.lib.cleanSource ./.<span class="kw">;}</span>;</a>
<a class="sourceLine" id="cb4-11" data-line-number="11"></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  <span class="co"># Instantiate a package set using the generated file.</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  <span class="ex">pkgSet</span> = haskell.mkCabalProjectPkgSet {</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">    <span class="ex">plan-pkgs</span> = import pkgPlan<span class="kw">;</span></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">    <span class="ex">pkg-def-extras</span> = []<span class="kw">;</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    <span class="ex">modules</span> = []<span class="kw">;</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  };</a>
<a class="sourceLine" id="cb4-18" data-line-number="18"></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">  <span class="ex">site</span> = import ./nix/site.nix { nixpkgs = pin<span class="kw">;</span> <span class="ex">hspkgs</span> = pkgSet.config.hsPkgs<span class="kw">;</span> };</a>
<a class="sourceLine" id="cb4-20" data-line-number="20"></a>
<a class="sourceLine" id="cb4-21" data-line-number="21"><span class="kw">in</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22">  <span class="kw">{</span> <span class="ex">eventlog2html</span> = pkgSet.config.hsPkgs.eventlog2html.components.exes.eventlog2html <span class="kw">;</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">    <span class="ex">site</span> = site<span class="kw">;</span> <span class="kw">}</span></a></code></pre></div>
<p>The <code>callCabalProjectToNix</code> function is the key. That is the function which calls <code>new-configure</code> to create the build plan directly using cabal. It produces the same result as calling <code>plan-to-json</code> manually, as <a href="https://input-output-hk.github.io/haskell.nix/user-guide/cabal-projects/">the documentation</a> explains how you should use <code>haskell.nix</code>. Therefore, the rest of the documentation can be followed but with the difference that the result of <code>callCabalProjectToNix</code> is passed as an argument to <code>mkCabalProjectPkgSet</code> rather than an explicit <code>pkgs.nix</code> file.</p>
<p>A derivation which generates the documentation site is also created. The definition is simple because <code>haskell.nix</code> takes care of building the site generator for us. All the derivation does it apply the site generator to the contents of the <code>docs/</code> subdirectory.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">{</span> <span class="ex">nixpkgs</span>, hspkgs <span class="kw">}</span>:</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ex">nixpkgs.stdenv.mkDerivation</span> {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="ex">name</span> = <span class="st">&quot;docs-0.1&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="ex">src</span> = nixpkgs.lib.cleanSource ../docs<span class="kw">;</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="ex">LANG</span> = <span class="st">&quot;en_US.UTF-8&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  <span class="ex">LOCALE_ARCHIVE</span> = <span class="st">&quot;</span><span class="va">${nixpkgs</span><span class="er">.glibcLocales</span><span class="va">}</span><span class="st">/lib/locale/locale-archive&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  <span class="ex">buildInputs</span> = [ hspkgs.hakyll-eventlog.components.exes.site ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  <span class="ex">preConfigure</span> = <span class="st">&#39;&#39;</span>export LANG=<span class="st">&quot;en_US.UTF-8&quot;</span><span class="kw">;</span><span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">  <span class="ex">buildPhase</span> = <span class="st">&#39;&#39;</span>site build<span class="st">&#39;&#39;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">  <span class="ex">installPhase</span> = <span class="st">&#39;&#39;</span>cp -r _site <span class="va">$out</span><span class="st">&#39;&#39;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-16" data-line-number="16">}</a></code></pre></div>
<p>Evaluating <code>default.nix</code> results in the a set containing the two outputs of the project. The executable <code>eventlog2html</code> and the documentation site. You can build each attribute locally</p>
<pre><code>cachix use mpickering
nix build -f . eventlog2html
nix build -f . site</code></pre>
<p>but also by passing a link to the generated github tarball.</p>
<pre><code>nix run -f https://github.com/mpickering/eventlog2html/archive/master.tar.gz eventlog2html -c eventlog2html my-leaky-program.eventlog</code></pre>
<h2 id="updated-travis-configuration">Updated Travis configuration</h2>
<p>The build job now calls nix to build these scripts and uses the <code>-o</code> flag to place the output into the <code>site</code> directory. The precise location where Travis expected to find the generated site so the deployment step can now find the files.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">-</span> <span class="fu">stage:</span><span class="at"> build documentation</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="fu">script:</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">      <span class="kw">-</span> <span class="fu">nix-env -iA cachix -f https:</span><span class="at">//cachix.org/api/v1/install</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">      <span class="kw">-</span> cachix use mpickering</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">-</span> cachix push mpickering --watch-store&amp;</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">      <span class="kw">-</span> nix-build -A site -o site</a></code></pre></div>
<p>We use Cachix to cache the result of building the individual derivations. This makes a huge difference to the total time that CI takes to run.</p>
<div class="alert alert-info" data-role="alert">
<p>You can greatly speed up the initial CI runs by pushing local build artifacts to travis.</p>
<pre><code>nix-store -qR --include-outputs $(nix-instantiate default.nix) | cachix push mpickering</code></pre>
</div>
<h2 id="conclusion">Conclusion</h2>
<p>That’s basically it. Despite a complicated amalgamation of tools, everything worked out nicely together without any horrible hacks. All I had to do was to work out how to fix the pieces together. When using bleeding edge technology such as <code>haskell.nix</code>, this isn’t always straightforward but now I’ve documented my struggles the next person should find it easier.</p>
<h2 id="addendum-using-secure-env-vars-in-travis">Addendum: Using secure env vars in Travis</h2>
<p>We need to set two env vars for CI to work. You have to encrypt these so you can place them into the public <code>.travis.yml</code> file without exposing secrets.</p>
<ul>
<li><code>GITHUB_TOKEN</code> - To allow travis to push to the repo</li>
<li><code>CACHIX_SIGNING_KEY</code> - To allow Cachix to push to a cache</li>
</ul>
<p>To generate the <code>GITHUB_TOKEN</code> go to <a href="https://github.com/settings/tokens">GitHub settings</a> and generate a token with the <code>public_repo</code> permissions.</p>
<p>The <code>CACHIX_SIGNING_KEY</code> can be found in <code>~/.config/cachix/cachix.dhall</code> in the <code>secreyKey</code> field for the corresponding binary cache.</p>
<p>Once you have the keys you have to encrypt them using the <code>travis</code> command line application.</p>
<pre><code>nix-shell -p travis
travis encrypt GITHUB_TOKEN=token
travis encrypt CACHIX_SIGNING_KEY=token</code></pre>
<p>Then copy and paste the result into your <code>.travis.yml</code> file. Make sure you add the <code>-</code> so the field is treated as a list. Otherwise Travis will ignore one of your keys.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">env:</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="fu">global:</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="co"># github</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="kw">-</span> <span class="fu">secure:</span><span class="at"> &lt;enrypted-key-1&gt;</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    <span class="co"># cachix</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    <span class="kw">-</span> <span class="fu">secure:</span><span class="at"> &lt;encrypted-key-2&gt;</span></a></code></pre></div>
]]></summary>
</entry>
<entry>
    <title>Tools for working on GHC</title>
    <link href="http://mpickering.github.io/posts/2019-06-11-ghc-tools.html" />
    <id>http://mpickering.github.io/posts/2019-06-11-ghc-tools.html</id>
    <published>2019-06-11T00:00:00Z</published>
    <updated>2019-06-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Tools for working on GHC </h2>
<p class="text-muted">
    Posted on June 11, 2019
    
</p>

<p>In the old days of the Make build system, the only reliable IDE-like feature which was useful whilst working on GHC was a tags file. Even loading GHC into GHCi was not easily possible, the most simple of interactive development workflows. Thankfully now times are changing, there are now build targets to start a GHCi session which enables developers to use tooling such as <a href="https://github.com/ndmitchell/ghcid">ghcid</a> or <a href="https://marketplace.visualstudio.com/items?itemName=dramforever.vscode-ghc-simple">vscode-ghc-simple</a>. Something which is quite important when working on a project with over 500 modules!</p>
<p>In this post we’ll briefly describe some recent advancements in developer tooling which have been made possible by the move to Hadrian.</p>
<!--more-->
<h2 id="ghci"><code>ghci</code></h2>
<p>The first target allows a developer to load GHC into GHCi. The <code>-fno-code</code> option is used which means that you can’t evaluate any expressions. It is useful for rapid feedback.</p>
<script id="asciicast-EKHiPuGgxhXz0ZHQgtR3OQd9G" src="https://asciinema.org/a/EKHiPuGgxhXz0ZHQgtR3OQd9G.js" async></script>
<h2 id="ghcid"><code>ghcid</code></h2>
<p><code>ghcid</code> can be used whilst working on <code>ghc</code> by invoking the <code>./hadrian/ghci.sh</code> target.</p>
<script id="asciicast-HAu0U5cVbneuujaoUA92Nxld5" src="https://asciinema.org/a/HAu0U5cVbneuujaoUA92Nxld5.js" async></script>
<p>There is a <code>.ghcid</code> file included <a href="https://gitlab.haskell.org/ghc/ghc/blob/master/.ghcid">in the repo</a> which includes some basic settings instructing <code>.ghcid</code> to reload the session if <code>hadrian/</code> changes. It might also be useful to add further directories here so that working with the many components of <code>ghc</code> is seamless.</p>
<h2 id="haskell-ide-engine"><code>haskell-ide-engine</code></h2>
<p>Once you have a working <code>ghci</code> target then in theory it becomes possible to use all other tooling with your build system. I realised that it would be possible to get <code>haskell-ide-engine</code> working with <code>ghc</code> but it required a <a href="https://github.com/haskell/haskell-ide-engine/pull/1126">very significant refactor</a>.</p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
Here's a short demo of using haskell-ide-engine on GHC's code base using my fork which integrates HIE into hadrian/cabal/rules_haskell/stack/obelisk <a href="https://t.co/rA1ps7dSb1">pic.twitter.com/rA1ps7dSb1</a>
</p>
— Matthew Pickering (<span class="citation" data-cites="mpickering_">(<span class="citeproc-not-found" data-reference-id="mpickering_"><strong>???</strong></span>)</span>) <a href="https://twitter.com/mpickering_/status/1110874588509016064?ref_src=twsrc%5Etfw">March 27, 2019</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>As a result, the branch can’t easily be merged back into the main repo but once it is merged then <code>haskell-ide-engine</code> will be more flexible and target agnostic.</p>
<h2 id="future-work-running-main">Future work: running <code>:main</code></h2>
<p>A final <a href="https://gitlab.haskell.org/ghc/ghc/issues/16672">goal</a> is to be able to run GHC’s <code>main</code> function from inside the interpreter. In order to do this it’s necessary to interpret the code rather than pass <code>-fno-code</code>. With some modifications to the <code>./hadrian/ghci.sh</code> script and patches by Michael Sloan we have been able to load load <code>ghc</code> into <code>GHCi</code> in the interpreted mode.</p>
<p>Unfortunately, this isn’t enough as in order to build programs with <code>HEAD</code> you also need to build libraries such as <code>base</code> with <code>HEAD</code>. The way around this is to first compile stage2 and then use the stage2 compiler to launch GHCi and load GHC into that. Then the libraries will be the correct versions and can be used to compile other modules.</p>
<p>A few months ago I got this working but since then it seems that the workflow <a href="https://gitlab.haskell.org/ghc/ghc/issues/16797">has been broken</a>. It’s a bit unfortunate that you have to jump through so many hoops in order to compile even a simple module but this is a unavoidable consequence of how GHC compiles and uses modules.</p>
<h3 id="ghci-debugger">GHCi Debugger</h3>
<p>Once you can execute <code>:main</code>, you can also use the GHCi debugger to debug GHC itself! This works without any problems but until you can use <code>:main</code> to compile programs then its of limited utility. I used the debugger to find the original reason why <code>:main</code> was failing whe compiling a program.</p>
]]></summary>
</entry>
<entry>
    <title>Making use of GHC bindists built by GitLab CI</title>
    <link href="http://mpickering.github.io/posts/2019-06-11-ghc-artefact.html" />
    <id>http://mpickering.github.io/posts/2019-06-11-ghc-artefact.html</id>
    <published>2019-06-11T00:00:00Z</published>
    <updated>2019-06-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Making use of GHC bindists built by GitLab CI </h2>
<p class="text-muted">
    Posted on June 11, 2019
    
</p>

<p>The new GHC GitLab CI infrastructure builds hundreds of different commits a week. Each commit on <code>master</code> is built, as well as any merge requests; each build produces an bindist which can be downloaded and installed on the relevant platform.</p>
<p><a href="https://github.com/mpickering/ghc-artefact-nix"><code>ghc-artefact-nix</code></a> provides a program <code>ghc-head-from</code> which downloads and enters a shell providing an artefact built with GitLab CI.</p>
<!--more-->
<h2 id="using-ghc-artefact-nix">Using <code>ghc-artefact-nix</code></h2>
<p>You can install <code>ghc-head-from</code> using <a href="https://github.com/nix-community/NUR"><code>NUR</code></a>.</p>
<pre><code>nix-shell -p nur.repos.mpickering.ghc-head-from</code></pre>
<p>There are three modes of operation.</p>
<h3 id="grab-a-recent-commit-from-master">Grab a recent commit from <code>master</code></h3>
<pre><code>ghc-head-from</code></pre>
<h3 id="grab-a-merge-request">Grab a merge request</h3>
<pre><code>ghc-head-from 1107</code></pre>
<h3 id="grab-a-specific-bindist-for-example-from-a-branch-or-fork">Grab a specific bindist (for example, from a branch or fork)</h3>
<pre><code>ghc-head-from https://gitlab.haskell.org/ghc/ghc/-/jobs/98842/artifacts/raw/ghc-x86_64-fedora27-linux.tar.xz</code></pre>
<p>The URL you provide has to be a direct link to a <code>fedora27</code> bindist.</p>
<h2 id="technical-details">Technical Details</h2>
<p>The bindist is downloaded from the (very flaky) CDN and patched to remove platform specific paths. The <code>fedora27</code> job is used because it is built using <code>ncurses6</code> which works better with nix.</p>
<h3 id="using-an-artefact-in-a-nix-expression">Using an artefact in a nix expression</h3>
<p>The <a href="https://github.com/mpickering/old-ghc-nix"><code>old-ghc-nix</code></a> repo provides a <code>mkGhc</code> function which can be used in a nix expression to create an attribute for a specific bindist. It is also packaged using <code>NUR</code>.</p>
<pre><code>nur.repos.mpickering.ghc.mkGhc
  {  url = &quot;https://gitlab-artifact-url.com&quot;; hash = &quot;sha256&quot;; ncursesVersion = &quot;6&quot;; }</code></pre>
<p>The <code>ncursesVersion</code> attribute is important to set for <code>fedora27</code> jobs as the function assumes that the bindist was built with <code>deb8</code> which uses <code>ncurses5</code>.</p>
<p>If you plan on using the artefact for a while then make sure you click the “keep” button on the artefact download page as otherwise it will be deleted after a week. This is very useful if you are developing a library against an unreleased version of the compiler and want to make sure all your collaborators are using the same version of GHC.</p>
]]></summary>
</entry>
<entry>
    <title>A three-stage program you definitely want to write</title>
    <link href="http://mpickering.github.io/posts/2019-02-14-stage-3.html" />
    <id>http://mpickering.github.io/posts/2019-02-14-stage-3.html</id>
    <published>2019-02-14T00:00:00Z</published>
    <updated>2019-02-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> A three-stage program you definitely want to write </h2>
<p class="text-muted">
    Posted on February 14, 2019
    
</p>

<p>Writing programs explicitly in stages gives you guarantees that abstraction will be removed. A guarantee that the optimiser most certainly does not give you.</p>
<p>After spending the majority of my early 20s inside the optimiser, I decided enough was enough and it was time to gain back control over how my programs were partially evaluated.</p>
<p>So in this post I’ll give an example of how I took back control and eliminated two levels of abstraction for an interpreter by writing a program which runs in three stages.</p>
<p>Enter: An applicative interpreter for Hutton’s razor.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">eval ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> m <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">eval (<span class="dt">Val</span> n) <span class="fu">=</span> pure n</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">eval (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> (<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> eval e1 <span class="fu">&lt;*&gt;</span> eval e2</a></code></pre></div>
<p>Written simply at one level, there are two levels of abstraction which could be failed to be eliminated.</p>
<ol type="1">
<li>If we statically know the expression we can eliminate <code>Expr</code>.</li>
<li>If we statically know which <code>Applicative</code> then we can remove the indirection from the typeclass.</li>
</ol>
<p>Using typed Template Haskell we’ll work out how to remove both of these layers.</p>
<!--more-->
<h2 id="eliminating-the-expression">Eliminating the Expression</h2>
<p>First we’ll have a look at how to stage the program just to eliminate the expression without discussion the application fragment. This is a two-stage program.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Two</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">TExpQ</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">eval (<span class="dt">Val</span> n) <span class="fu">=</span> [<span class="fu">||</span> n <span class="fu">||</span>]</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">eval (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> [<span class="fu">||</span> <span class="fu">$$</span>(eval e1) <span class="fu">+</span> <span class="fu">$$</span>(eval e2) <span class="fu">||</span>]</a></code></pre></div>
<p>The eval function takes an expression and generates code which unrolls the expression that needs to be evaluated.</p>
<p>Splicing in <code>eval</code> gives us a chain of additions which are computed at run-time.</p>
<pre><code>$$(eval (Add (Val 1) (Val 2)))
=&gt; 1 + 2</code></pre>
<p>By explicitly separating the program into stages we know that there will be no mention of <code>Expr</code> in the resulting program.</p>
<h2 id="eliminating-the-applicative-functor">Eliminating the Applicative Functor</h2>
<p>That’s good. Eliminating the <code>Expr</code> data type was easy. We’ll have to work a bit more to eliminate the applicative.</p>
<p>In the first stage, we will eliminate the expression in the same manner but instead of producing an <code>Int</code>, we will produce a <code>SynApplicative</code> which is a syntactic representation of an applicative. This allows us to inspect the structure of the program in the second stage and remove that overhead as well.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">SynApplicative</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="dt">Return</span><span class="ot"> ::</span> <span class="dt">WithCode</span> a <span class="ot">-&gt;</span> <span class="dt">SynApplicative</span> a</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="dt">App</span><span class="ot">  ::</span> <span class="dt">SynApplicative</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">SynApplicative</span> a <span class="ot">-&gt;</span> <span class="dt">SynApplicative</span> b</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="kw">data</span> <span class="dt">WithCode</span> a <span class="fu">=</span> <span class="dt">WithCode</span> {<span class="ot"> _val ::</span> a,<span class="ot"> _code ::</span> <span class="dt">TExpQ</span> a }</a></code></pre></div>
<p><code>WithCode</code> is a wrapper which pairs a value with a code fragment which was used to produce that value.</p>
<p>If you notice in the earlier example, this wasn’t necessary when it was known that we needed to persist an <code>Int</code>, as there is a <code>Lift</code> instance for <code>Int</code>. However, in general, not all values can be persisted so using <code>WithCode</code> is more general and flexible, if a bit more verbose.</p>
<p><code>elimExpr</code> eliminates the first layer of abstraction and returns code which generates a <code>SynApplicative</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">elimExpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">TExpQ</span> (<span class="dt">SynApplicative</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">elimExpr (<span class="dt">Val</span> n) <span class="fu">=</span> [<span class="fu">||</span> <span class="dt">Return</span> (<span class="dt">WithCode</span> n (liftT n)) <span class="fu">||</span>]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">elimExpr (<span class="dt">Add</span> e1 e2) <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">   [<span class="fu">||</span> <span class="dt">Return</span> (<span class="dt">WithCode</span> (<span class="fu">+</span>) codePlus)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">        <span class="ot">`App`</span> <span class="fu">$$</span>(elimExpr e1)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">        <span class="ot">`App`</span> <span class="fu">$$</span>(elimExpr e2) <span class="fu">||</span>]</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="ot">liftT ::</span> <span class="dt">Lift</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">TExpQ</span> a</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">liftT <span class="fu">=</span> unsafeTExpCoerce <span class="fu">.</span> lift</a>
<a class="sourceLine" id="cb5-10" data-line-number="10"></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">codePlus <span class="fu">=</span> [<span class="fu">||</span> (<span class="fu">+</span>) <span class="fu">||</span>]</a></code></pre></div>
<p>In the case for <code>Add</code> we encounter a situation where we would have liked to use nested brackets to persist the value of <code>[|| (+) ||]</code>. Instead you have to lift it to the top level and then persist that identifier.</p>
<p>Next, it’s time to provide an interpreter to remove the abstraction of the applicative. In order to do this, we need to provide a dictionary which will be used to give the interpretation of the applicative commands.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ApplicativeDict</span> m <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="dt">ApplicativeDict</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    {<span class="ot"> _return ::</span> (forall a <span class="fu">.</span> <span class="dt">WithCode</span> (a <span class="ot">-&gt;</span> m a)),</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ot">      _ap     ::</span> (forall a b <span class="fu">.</span> <span class="dt">WithCode</span> (m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    }</a></code></pre></div>
<p><code>WithCode</code> is necessary again as it will be used to generate a program so it’s necessary to know how to implement the methods.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">elimApplicative</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">SynApplicative</span> a</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="ot">-&gt;</span> <span class="dt">ApplicativeDict</span> m</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">TExpQ</span> (m a)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">elimApplicative (<span class="dt">Return</span> v) d<span class="fu">@</span><span class="dt">ApplicativeDict</span>{<span class="fu">..</span>}</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="fu">=</span> [<span class="fu">||</span> <span class="fu">$$</span>(_code _return) <span class="fu">$$</span>(_code v) <span class="fu">||</span>]</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">elimApplicative (<span class="dt">App</span> e1 e2) d<span class="fu">@</span><span class="dt">ApplicativeDict</span>{<span class="fu">..</span>}</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  <span class="fu">=</span> [<span class="fu">||</span> <span class="fu">$$</span>(_code _ap) <span class="fu">$$</span>(elimApplicative e1 d) <span class="fu">$$</span>(elimApplicative e2 d) <span class="fu">||</span>]</a></code></pre></div>
<p>This interpretation is very boring as it just amounts to replacing all the constructors with their implementations. However, it is exciting that we have guaranteed the removal of the overhead of the applicative abstraction.</p>
<h2 id="running-the-splice">Running the Splice</h2>
<p>Now that we’ve written two functions independently to to eliminate the two layers, they need to be combined together. This is the birth of our three-stage program.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Three</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ot">elim ::</span> <span class="dt">Identity</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">elim <span class="fu">=</span> <span class="fu">$$</span>(elimApplicative <span class="fu">$$</span>(elimExpr (<span class="dt">Add</span> (<span class="dt">Val</span> <span class="dv">1</span>) (<span class="dt">Val</span> <span class="dv">2</span>))) identityDict)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">identityDict <span class="fu">=</span> <span class="dt">ApplicativeDict</span>{<span class="fu">..</span>}</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    _return <span class="fu">=</span> <span class="dt">WithCode</span> <span class="dt">Identity</span> [<span class="fu">||</span> <span class="dt">Identity</span> <span class="fu">||</span>]</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    _ap <span class="fu">=</span> <span class="dt">WithCode</span> idAp [<span class="fu">||</span> idAp <span class="fu">||</span>]</a>
<a class="sourceLine" id="cb8-10" data-line-number="10"></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="ot">idAp ::</span> <span class="dt">Identity</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">idAp (<span class="dt">Identity</span> f) (<span class="dt">Identity</span> a) <span class="fu">=</span> <span class="dt">Identity</span> (f a)</a></code></pre></div>
<p><code>elim</code> is the combination of <code>elimApplicative</code> and <code>elimExpr</code>. The nested splices indicate that the program is more than two levels.</p>
<p>Using <code>-ddump-splices</code> we can have a look at the program that gets generated.</p>
<pre><code>Test.hs:10:30-59: Splicing expression
    elimExpr (Add (Val 1) (Val 2))
  ======&gt;
    ((Return ((WithCode (+)) codePlus)
        `App` Return ((WithCode 1) (liftT 1)))
       `App` Return ((WithCode 2) (liftT 2)))
Test.hs:10:11-73: Splicing expression
    elimApplicative $$(elimExpr (Add (Val 1) (Val 2))) identityDict
  ======&gt;
    (idAp ((idAp (Identity (+))) (Identity 1))) (Identity 2)</code></pre>
<p>Both steps appear in the debug output with the code which was produced at each step. Notice that we had very precise control over what code was generated and that functions like <code>idAp</code> are not inlined. In this case, the compiler will certainly inline <code>idAp</code> and so on but in general it might be useful to generate code which contains calls to <code>GHC.Exts.inline</code> to force even recursive functions to be inlined once.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In general, splitting your program up into stages is quite difficult so mechanisms like type class specialisation will be easier to achieve. In controlled situations though, staging gives you the guarantees you need.</p>
<h2 id="related-links">Related Links</h2>
<ul>
<li><a href="https://www.reddit.com/r/haskell/comments/aqkv9k/a_threestage_program_you_definitely_want_to_write/">Reddit Discussion</a></li>
<li><a href="https://github.com/mpickering/three-level">Code</a></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Implementing Nested Quotations</title>
    <link href="http://mpickering.github.io/posts/2019-01-31-nested-brackets.html" />
    <id>http://mpickering.github.io/posts/2019-01-31-nested-brackets.html</id>
    <published>2019-01-31T00:00:00Z</published>
    <updated>2019-01-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Implementing Nested Quotations </h2>
<p class="text-muted">
    Posted on January 31, 2019
    
</p>

<p>Quotation is one of the key elements of metaprogramming. Quoting an expression <code>e</code> gives us a representation of <code>e</code>.</p>
<pre><code>[| e |] :: Repr</code></pre>
<p>What this representation is depends on the metaprogramming framework and what we can do with the representation depends on the representation. The most common choice is to dissallow any inspection of the representation type relying on the other primative operation, the splice, in order to insert quoted values into larger programs.</p>
<p>The purpose of this post is to explain how to implemented nested quotations. From our previous example, quoting a term <code>e</code>, gives us a term which represents <code>e</code>. It follows that we should be allowed to nest quotations so that quoting a quotation gives us a representation of that quotation.</p>
<pre><code>[| [| 4 + 5 |] |]</code></pre>
<p>However, nesting brackets in this manner has been disallowed in Template Haskell for a number of years despite nested splices being permitted. I wondered why this restriction was in place and it seemed that <a href="https://mail.haskell.org/pipermail/ghc-devs/2019-January/016939.html">no one knew the answer</a>. It turns out, there was no technical reason and implementing nested brackets is straightforward once you think about it correctly.</p>
<!--more-->
<h2 id="template-haskell">Template Haskell</h2>
<p>We will now be concrete and talk about how these mechanisms are implemented in Template Haskell.</p>
<p>In Template Haskell the representation type of expressions is called <code>Exp</code>. It is a <a href="http://hackage.haskell.org/package/template-haskell-2.14.0.0/docs/Language-Haskell-TH-Syntax.html#t:Exp">simple ADT</a> which mirrors source Haskell programs very closely. For example quoting <code>2 + 3</code> might be represented by:</p>
<pre><code>[| 2 + 3 |] :: Exp
= InfixE (Just (LitE 5)) (VarE +) (Just (LitE 5))</code></pre>
<p>Because <code>Exp</code> is a normal data type we can define its representation in the same manner as any user defined data type. This is the purpose of the <code>Lift</code> type class which defines how to turn a value into its representation.</p>
<pre><code>class Lift t where
  lift :: t -&gt; Q Exp</code></pre>
<p>So we just need to implement <code>instance Lift (Q Exp)</code> and we’re done. To do that we implement a general instance for <code>Lift (Q a)</code> and then also an instance for <code>Exp</code>.</p>
<pre><code>instance Lift a =&gt; Lift (Q a) where
  lift qe = qe &gt;&gt;= \b&#39; -&gt; lift b&#39; &gt;&gt;= \b&#39;&#39; -&gt; return ((VarE &#39;return) `AppE` b&#39;&#39;)</code></pre>
<p>This instance collapses effects from building the inner code value into a single outer layer. In order to make the types line up correctly, we have to insert a call to <code>return</code> to the result of lifting the inner expression.</p>
<p>Instances for <code>Exp</code> and all its connected types are straightforward to define and thankfully we can use the <code>DeriveLift</code> extension in order to derive them.</p>
<pre><code>deriving instance Lift Exp
... 40 more instances
deriving instance Lift PatSynDir</code></pre>
<p>It’s now possible to write a useless program which lifts a boolean value twice before splicing it twice to get back the original program.</p>
<pre><code>-- foo = True
foo :: Bool
foo = $($(lift (lift True)))</code></pre>
<p>Running this program with <code>-ddump-splices</code> would show us that when the first splice is run, the code that is insert is the representation of <code>True</code>. After the second splice is run, this representation is turned back into <code>True</code>.</p>
<h2 id="cross-stage-persistance">Cross Stage Persistance</h2>
<p>If you use variables in a bracket the compiler has to persist their value from one stage to another so that they remain bound and bound to the correct value when we splice in the quote.</p>
<p>For example, quoting <code>x</code>, we need to remember that the <code>x</code> refers to the <code>x</code> bound to the top-level which is equal to <code>5</code>.</p>
<pre><code>x = 5

foo = [| x |]</code></pre>
<p>If we didn’t when splicing in <code>foo</code>, in another module, we would use whatever <code>x</code> was in scope or end up with an unbound reference to <code>x</code>. No good at all.</p>
<p>For a locally bound variable, we can’t already precisely know the value of the variable. We will only know it later at runtime when the function is applied.</p>
<pre><code>foo x = [| x |]</code></pre>
<p>Thus, we must know for any value that <code>x</code> can take, how we construct its representation. If we remember, that’s precisely what the <code>Lift</code> class is for. So, to correct this cross-stage reference, we replace the variable <code>x</code> with a splice (which lowers the level by one) and a call to <code>lift</code>.</p>
<pre><code>foo x = [| $(lift x) |]</code></pre>
<h3 id="nesting-brackets">Nesting Brackets</h3>
<p>The logic for persisting variables has to be extended to work with nested brackets.</p>
<pre><code>foo3 :: Lift a =&gt; a -&gt; Q Exp
foo3 x = [| [| x |] |]</code></pre>
<p>In <code>foo3</code>, <code>x</code> is used at level 2 but defined at level 0, hence we must insert two levels of splices and two levels of lifting to rectify the stages.</p>
<pre><code>foo3 :: Lift a =&gt; a -&gt; Q Exp
foo3 x = [| [| $($(lift(lift x))) |] |]</code></pre>
<p>Now with nested brackets, you can also lift variables defined in future stages.</p>
<pre><code>foo4 :: Q Exp
foo4 = [| \x -&gt; [| x |] |]</code></pre>
<p>Now <code>x</code> is defined at stage 1 and used in stage 2. So, like normal, we need to insert a lift and splice in order to realign the stages. This time, just one splice as we just need to lift it one level.</p>
<pre><code>foo4 :: Q Exp
foo4 = [| \x -&gt; [| $(lift x) |] |]</code></pre>
<h1 id="implementing-nested-brackets">Implementing Nested Brackets</h1>
<h2 id="implementing-splices">Implementing Splices</h2>
<p>After renaming a bracket, all the splices inside the bracket are moved into an associated environment.</p>
<pre><code>foo = [| $(e) |]
=&gt; [| x |]_{ x = e }</code></pre>
<p>When renaming the RHS of <code>foo</code>, we replace the splice of <code>e</code> with a new variable <code>x</code>, this is termed the “splice point” for the expression <code>e</code>. Then, a new binding is added to the environment for the bracket which says that any reference to <code>x</code> inside the bracket refers to <code>e</code>. That means when we make the representation of the code inside the bracket, occurences of <code>x</code> are replaced with <code>e</code> directly (rather than a representation of <code>x</code>) in the program.</p>
<p>The same mechanism is used for the implicit splices we create by instances of cross-stage persistence.</p>
<pre><code>qux x = [| x |]
        =&gt; [| $(lift x) |]
        =&gt; [| x&#39; |]_{ x&#39; = lift x }</code></pre>
<p>The environment is special in the sense that it connects a stage 1 variable with an expression at stage 0.</p>
<p>How is this implemented? When we see a splice we rename it and the write it to a state variable whose scope is delimited by the bracket. Once the contents of the bracket is finished being renamed we read the contents and use that as the environment.</p>
<h2 id="generalisation-to-n-levels">Generalisation to n-levels</h2>
<p>Nested splices work immediately with nested brackets. When there is a nested bracket, the expression on the inside is first floated outwards into the inner brackets environment.</p>
<pre><code>foo n = [| [| $($(n)) |] |]
      =&gt; [| [| x |]_{x=$(n)} |]
      =&gt; [| [| x |]_{x = y} |]_{y = n}</code></pre>
<p>Then it is floated again to the top-level leaving a behind a trail of bindings.</p>
<h2 id="representing-quotes">Representing Quotes</h2>
<p>Template Haskell represents renamed terms so that references remain constent after splicing. As such, our representation of a quotation in the TH AST should reflect the renamed form of brackets which includes the environment.</p>
<pre><code>data Exp = ... | BrackE [(Var, Exp)] Exp | ...</code></pre>
<p>The constructor therefore takes a list which is the environment mapping splice points to expressions and a representation of the quoted expression.</p>
<p>It is invariant that there are no splice forms in renamed syntax as they are all replaced during renaming into this environment form.</p>
<p>To represent a simple quoted expression will have an empty environment but if we also use splices then these are included as well.</p>
<pre><code>[| [| 4 |] |] =&gt; BrackE [] (representation of 4)

[| [| $(foo) |] |] =&gt; BrackE [(x, representation of foo)] (representation of x)</code></pre>
<h1 id="conclusion">Conclusion</h1>
<p>Those are the details of implementing nested brackets, if you ever need to for your own language. In the end, the patch was quite simple but it took quite a bit of thinking to work out the correct way to propagate the splices and build the correct representation.</p>
]]></summary>
</entry>
<entry>
    <title>Packaging a Haskell library for artefact evaluation using nix</title>
    <link href="http://mpickering.github.io/posts/2018-09-19-nix-artefacts.html" />
    <id>http://mpickering.github.io/posts/2018-09-19-nix-artefacts.html</id>
    <published>2018-09-19T00:00:00Z</published>
    <updated>2018-09-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Packaging a Haskell library for artefact evaluation using nix </h2>
<p class="text-muted">
    Posted on September 19, 2018
    
</p>

<p>This year I packaged two artefacts for the ICFP artefact evaluation process. This post explains the system I used to make it easy to produce the docker images using nix. I hope this documentation will be useful for anyone else submitting a Haskell library for evaluation.</p>
<p>The end result will be an <code>artefact.nix</code> file which is used to build a docker image to submit. It will be an entirely reproducible process as we will fix the versions of all the dependencies we use.</p>
<!--more-->
<h2 id="the-structure-of-the-artefact">The structure of the artefact</h2>
<p>In this example, I am going to package the artefact from the paper <a href="https://dl.acm.org/citation.cfm?id=3236780">“Generic Deriving of Generic Traversals”</a>. The artefact was a Haskell library and an executable which ran some benchmarks. The resulting artefact will be a docker image which contains:</p>
<ol type="1">
<li>The source code of the library</li>
<li>The source code for the benchmarks</li>
<li>The executable of the benchmarks</li>
<li>An environment where it is possible to compile the library and benchmarks</li>
</ol>
<p>To start with, I will assume that we have placed the source code and benchmarks code in our current directory. We will add the rest of the files</p>
<pre><code>&gt;&gt;&gt; ls
generic-lens-1.0.0.1/
benchmarks/</code></pre>
<h2 id="step-1-pinning-nixpkgs">Step 1: Pinning nixpkgs</h2>
<p>The most important step of the whole process is to “pin” our version of nixpkgs to a specific version so that anyone else trying to build the image will use the same versions of all the libraries and system dependencies.</p>
<p>Once we have established a commit of nixpkgs that our package builds with. We can use <code>nix-prefetch-git</code> in order to create <code>nixpkgs.json</code> which will provide the information about the pin.</p>
<pre><code>nix-prefetch-git --rev 651239d5ee66d6fe8e5e8c7b7a0eb54d2f4d8621 --url https://github.com/NixOS/nixpkgs.git &gt; nixpkgs.json</code></pre>
<p>Now we have a file, <code>nixpkgs.json</code> which specifies which version of nixpkgs we should use.</p>
<p>We then need to load this file. Some boilerplate, <code>nixpkgs.nix</code>, will do that for us.</p>
<pre><code>opts:
let
   hostPkgs = import &lt;nixpkgs&gt; {};
   pinnedVersion = hostPkgs.lib.importJSON ./nixpkgs.json;
   pinnedPkgs = hostPkgs.fetchFromGitHub {
     owner = &quot;NixOS&quot;;
     repo = &quot;nixpkgs&quot;;
     inherit (pinnedVersion) rev sha256;
   };
in import pinnedPkgs opts</code></pre>
<p><code>nixpkgs.nix</code> will be imported in <code>artefact.nix</code> and will determine precisely the version of all dependencies we will use.</p>
<h2 id="step-2-using-dockertools">Step 2: Using <code>dockerTools</code></h2>
<p>Now we have specified the set of dependencies we want to use we can go about starting to build our docker image. Nixpkgs provides a convenient set of functions called <code>dockerTools</code> in order to create docker images in a declarative manner. This is the start of our <code>artefact.nix</code> file.</p>
<pre><code>let
  pkgs = import ./nixpkgs.nix { };
in
with pkgs;
let
    debian = dockerTools.pullImage
      { imageName = &quot;debian&quot;
      ; imageTag = &quot;9.5&quot;
      ; sha256 = &quot;1jxci0ph7l5fh0mm66g4apq1dpcm5r7gqfpnm9hqyj7rgnh44crb&quot;; };
in
dockerTools.buildImage {
  name = &quot;generic-lens-artefact&quot;;

  fromImage = debian;

  contents = [  bashInteractive
                glibcLocales
             ];

  config = {
    Env = [&quot;LANG=en_US.UTF-8&quot;
           &quot;LOCALE_ARCHIVE=${glibcLocales}/lib/locale/locale-archive&quot;];
    WorkingDir = &quot;/programs&quot;;
  };
}</code></pre>
<p>This is the barebones example we’ll start from. We firstly import <code>nixpkgs.nix</code> which defines the package set we want to use. Our docker file will be based on <code>debian</code>, and so we use the <code>dockerTools.pullImage</code> function to get this base image. The <code>imageName</code> comes from docker hub and the <code>imageTag</code> indicates the specific tag.</p>
<p>This image is our base image when calling <code>dockerTools.buildImage</code>. For now, we add the basic packages <code>bashInteractive</code> and <code>glibcLocales</code>, in the next step we will add the specific contents that we need for our artefact.</p>
<p>Setting the <code>LANG</code> and <code>LOCALE_ARCHIVE</code> env vars is important for Haskell programs as otherwise you can run into strange encoding errors.</p>
<p>This is a complete image which can already be build with <code>nix-build artefact.nix</code>. The result will be a <code>.tar.gz</code> which can be loaded into docker and run as normal.</p>
<h2 id="step-3-including-the-artefact">Step 3: Including the artefact</h2>
<p>First we’ll deal with making the executable itself available on the image. Remember that the source code of the benchmarks, which is a normal Haskell package, is located in <code>benchmarks/</code>.</p>
<p>We need to tell nix how to build the benchmarks. The standard way to do this is to use <code>cabal2nix</code> to generate a package specification which we will pass to <code>haskellPackages.callPackage</code>.</p>
<pre><code>cabal2nix benchmarks/ &gt; benchmarks.nix</code></pre>
<p>This will produce a file which looks a bit like</p>
<pre><code>{ mkDerivation, base, criterion, deepseq, dlist, dump-core
, generic-lens, geniplate-mirror, haskell-src, lens, mtl, one-liner
, parallel, plugin, random, stdenv, syb, transformers, uniplate
, weigh
}:
mkDerivation {
  pname = &quot;benchmarks&quot;;
  version = &quot;0.1.0.0&quot;;
  src = ./benchmarks;
  isLibrary = false;
  isExecutable = true;
  executableHaskellDepends = [
    base criterion deepseq dlist dump-core generic-lens
    geniplate-mirror haskell-src lens mtl one-liner parallel plugin
    random syb transformers uniplate weigh
  ];
  license = stdenv.lib.licenses.bsd3;
}</code></pre>
<p>Now we will add the executable to the docker image. A new definition is created in the let bindings and then we add the executable to the <code>contents</code> of the image.</p>
<pre><code>run-benchmarks = haskellPackages.callPackage ./benchmarks.nix {};</code></pre>
<p>So now our <code>contents</code> section will look like:</p>
<pre><code>  contents = [  bashInteractive
                glibcLocales
                run-benchmarks
                ];</code></pre>
<p>When we build this image, the executable will be available on the path by default. In our case, the user will type <code>bench</code> and it will run the benchmarks.</p>
<h2 id="step-4-including-the-source-files">Step 4: Including the source files</h2>
<p>The next step is to add the source files to the image. To do this we use the <code>runCommand</code> script to make a simple derivation which copies some files into the right place.</p>
<pre><code>benchmarks-raw = ./benchmarks;
benchmarks =
  runCommand &quot;benchmarks&quot; {} &#39;&#39;
  mkdir -p $out/programs/benchmarks
  cp -r ${benchmarks-raw}/* $out/programs/benchmarks
&#39;&#39;;</code></pre>
<p>All the derivation does is copy the directory into the nix store at a specific path. We then just add this to the <code>contents</code> list again and also do the same for the library itself and the README.</p>
<pre><code>  contents = [  bashInteractive
                glibcLocales
                run-benchmarks
                benchmarks
                readme
                library];</code></pre>
<p>Now once we build the docker image, we’ll have the executable <code>bench</code> available and also a file called <code>README</code> and two folders containing the library code and benchmarks code.</p>
<h2 id="step-5-an-environment-to-build-the-source-code">Step 5: An environment to build the source code</h2>
<p>Finally, we need to do two more things to make it possible to build the source programs in the container.</p>
<p>Including <code>cabal-install</code> in the contents is the first so that we can use <code>cabal</code> in the container.</p>
<pre><code>  contents = [  bashInteractive
                glibcLocales
                run-benchmarks
                benchmarks
                readme
                library
                cabal-install ];</code></pre>
<p>The second is much less obvious, we need to make sure that the necessary dependencies are already installed in the environment so that someone can just use <code>cabal build</code> in order to build the package. The way to achieve this is to modify the <code>benchmarks.nix</code> file and change <code>isLibrary</code> to <code>true</code>.</p>
<pre><code>-  isLibrary = false;
+  isLibrary = true;</code></pre>
<p>This means that all the build inputs for the benchmarks are propagated to the container so all the dependencies for the benchmarks will be available to rebuild them again.</p>
<h2 id="complete-artefact.nix">Complete <code>artefact.nix</code></h2>
<p>Here’s the complete <code>artefact.nix</code> that we ended up with. We also generated <code>nixpkgs.json</code>, <code>nixpkgs.nix</code> and <code>benchmarks.nix</code> along the way.</p>
<pre><code>let
  pkgs = import ./nixpkgs.nix {};
in
with pkgs;
let
    debian = dockerTools.pullImage
      { imageName = &quot;debian&quot;
      ; imageTag = &quot;9.5&quot;
      ; sha256 = &quot;1y4k42ljf6nqxfq7glq3ibfaqsq8va6w9nrhghgfj50w36bq1fg5&quot;; };

    benchmarks-raw = ./benchmarks;
    benchmarks =
      runCommand &quot;benchmarks&quot; {} &#39;&#39;
        mkdir -p $out/programs/benchmarks
        cp -r ${benchmarks-raw}/* $out/programs/benchmarks
      &#39;&#39;;

    library-raw = ./generic-lens-1.0.0.1;
    library =
      runCommand &quot;benchmarks&quot; {} &#39;&#39;
        mkdir -p $out/programs/library
        cp -r ${library-raw}/* $out/programs/library
      &#39;&#39;;

    readme-raw = ./README;
    readme =
      runCommand &quot;readme&quot; {} &#39;&#39;
        mkdir -p $out/programs
        cp ${readme-raw} $out/programs/README
      &#39;&#39;;

    run-benchmarks = haskellPackages.callPackage ./benchmarks.nix {};

in
dockerTools.buildImage {
  name = &quot;generic-lens-artefact&quot;;


  fromImage = debian;

  contents = [  bashInteractive
                cabal-install
                glibcLocales
                run-benchmarks
                benchmarks
                readme
                library];

  config = {
    Env = [&quot;LANG=en_US.UTF-8&quot;
           &quot;LOCALE_ARCHIVE=${glibcLocales}/lib/locale/locale-archive&quot;];
    WorkingDir = &quot;/programs&quot;;
  };
}</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Hopefully this tutorial will be useful for anyone having to package a Haskell library in future. Each artefact is different so you’ll probably have to modify some of the steps in order to make it work perfectly for you. It’s also possible that the <code>dockerTools</code> interface will change but it should be possible to modify the examples here to adapt to any minor changes. If you’re already using nix, you probably know what you’re doing anyway.</p>
<h2 id="related-links">Related Links</h2>
<ul>
<li><a href="https://vaibhavsagar.com/blog/2018/05/27/quick-easy-nixpkgs-pinning/">Quick and Easy Nixpkgs Pinning - Vaibhav Sagar</a></li>
<li><a href="https://nixos.org/nixpkgs/manual/#sec-pkgs-dockerTools"><code>dockerTools</code> documentation</a></li>
<li><a href="https://www.software.ac.uk/blog/2017-10-05-reproducible-environments-nix">Reproducible Environments With Nix - Blair Archibald</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/9h6xh2/packaging_a_haskell_library_for_artefact/">Reddit comments</a></li>
</ul>
]]></summary>
</entry>

</feed>
